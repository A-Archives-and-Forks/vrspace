<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
      <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
      <meta content="utf-8" http-equiv="encoding">
    <title>VRSpace:Selection</title>
    <style type="text/css">
    html, body {
      width: 100%;
      height:100%;
      margin: 0px;
      padding: 0px;
    }
    canvas {
      width: 98%;
      height:96%;
      padding-left: 0;
      padding-right: 0;
      margin-left: auto;
      margin-right: auto;
      display: block;
    }
    </style>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    <script src="./avatar.js"></script>
    <script src="./vrspace-ui.js"></script>
    </head>
  <body>

  <!-- canvas is not focusable by default, tabIndex does that -->
  <canvas id="renderCanvas" touch-action="none" tabIndex=0></canvas>

<script>
var canvas = document.getElementById("renderCanvas"); // Get the canvas element
// focus canvas so we get keyboard events, otherwise need to click on it first
canvas.focus();
var engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
var scene;
var ground;
var character;
var animationSelection;

var shadowGenerator;

var leftController;
var rightController;

var trackTime = Date.now();
//var trackDelay = 1000; // 1 fps
//var trackDelay = 100; // 10 fps
//var trackDelay = 40; // 25 fps
var trackDelay = 20; // 50 fps

var maxCameraPos;
var prevCameraPos;
var jumping;

var vrHelper;
var inXR = false;
var mirror = true;

var initXR = async function(scene) {
  const xrHelper = await scene.createDefaultXRExperienceAsync({floorMeshes:[ground]});

  vrHelper = xrHelper;

  if (xrHelper.baseExperience) {
    console.log("Using XR helper");

    xrHelper.baseExperience.onStateChangedObservable.add((state) => {
        console.log( "State: "+state );
        switch (state) {
            case BABYLON.WebXRState.IN_XR:
                // XR is initialized and already submitted one frame
                console.log( "Entered VR" );
                // Workaround for teleporation/selection bug
                xrHelper.teleportation.setSelectionFeature(null);
                // track controllers and camera
                scene.registerBeforeRender(trackXrDevices);
                inXR = true;
                // copy location from web camera
                //xrHelper.baseExperience.camera.setTransformationFromNonVRCamera(camera);
                break;
            case BABYLON.WebXRState.ENTERING_XR:
                // xr is being initialized, enter XR request was made
                console.log( "Entering VR" );
                break;
            case BABYLON.WebXRState.EXITING_XR:
                // edge has issues with this, before entering it exits
                // xr exit request was made. not yet done.
                scene.unregisterBeforeRender(trackXrDevices);
                console.log( "Exiting VR" );
                inXR = false;
                // make HUD track UniversalCamera
                //scene.unregisterBeforeRender(trackXrCamera);
                //scene.registerBeforeRender(trackWebCamera);
                break;
            case BABYLON.WebXRState_NOT_IN_XR:
                console.log( "Not in VR" );
                // self explanatory - either out or not yet in XR
                break;
        }
    });

    xrHelper.input.onControllerAddedObservable.add((xrController /* WebXRController instance */ ) => {
      console.log("Controller added: "+xrController.grip.name+" "+xrController.grip.name);
      console.log(xrController);
      if ( xrController.grip.id.toLowerCase().indexOf("left") >= 0 || xrController.grip.name.toLowerCase().indexOf("left") >=0 ) {
        leftController = xrController;
      } else if (xrController.grip.id.toLowerCase().indexOf("right") >= 0 || xrController.grip.name.toLowerCase().indexOf("right") >= 0) {
        rightController = xrController;
      } else {
        log("ERROR: don't know how to handle controller");
      }
    });

    var trackXrDevices = function() {
      if ( trackTime + trackDelay < Date.now()
          && character
          && character.body
          && character.body.processed
          && ! character.activeAnimation
        ) {
        trackTime = Date.now();
        // CHECKME: mirror left-right
        if ( leftController ) {
          if ( mirror ) {
            var leftPos = calcControllerPos( character.body.leftArm, leftController );
            character.reachFor( character.body.leftArm, leftPos );
          } else {
            var leftPos = calcControllerPos( character.body.rightArm, leftController );
            character.reachFor( character.body.rightArm, leftPos );
          }
        }
        if ( rightController ) {
          if ( mirror ) {
            var rightPos = calcControllerPos( character.body.rightArm, rightController );
            character.reachFor( character.body.rightArm, rightPos );
          } else {
            var rightPos = calcControllerPos( character.body.leftArm, rightController );
            character.reachFor( character.body.leftArm, rightPos );
          }
        }
        character.lookAt( calcCameraTarget() );
        trackHeight();
      }
    }

    var trackHeight = function() {
      //var cameraPos = xrHelper.input.xrCamera.position.y;
      var cameraPos = xrHelper.input.xrCamera.realWorldHeight;
      if ( maxCameraPos ) {
        var delta = cameraPos-prevCameraPos;
        var speed = delta/trackDelay*1000;
        if ( cameraPos > maxCameraPos && Math.abs(speed) > 1 ) {
          character.jump(cameraPos - maxCameraPos);
          jumping = Date.now();
        } else if ( jumping ) {
          var delay = Date.now() - jumping;
          if ( cameraPos <= maxCameraPos && delay > 300 ) {
            character.standUp();
            jumping = null;
          } else {
            character.jump(cameraPos - maxCameraPos);
          }
        } else {
          if ( delta > 0 ) {
            character.rise(delta);
          } else if ( delta < 0 ) {
            character.crouch(-delta);
          }
        }

      } else {
        maxCameraPos = cameraPos;
      }
      prevCameraPos = cameraPos;
    }

    var calcCameraTarget = function() {
      var cameraQuat = xrHelper.input.xrCamera.rotationQuaternion;
      var target = new BABYLON.Vector3(0,xrHelper.input.xrCamera.realWorldHeight,1);
      target.rotateByQuaternionAroundPointToRef(cameraQuat,character.headPos(),target);
      if ( mirror ) {
        target.z = -target.z;
      }
      return target;
    }

    var calcControllerPos = function( arm, xrController ) {
      var cameraPos = xrHelper.input.xrCamera.position;
      // this calc swaps front-back, like mirror image
      var pos = xrController.grip.absolutePosition.subtract( new BABYLON.Vector3(cameraPos.x, 0, cameraPos.z));
      var armLength = arm.lowerArmLength+arm.upperArmLength;
      if ( mirror ) {
        pos.z = - pos.z;
      }

      var pointerQuat = xrController.pointer.rotationQuaternion;
      arm.pointerQuat = pointerQuat;

      return pos;
    }


  } else {
    vrHelper = scene.createDefaultVRExperience({createDeviceOrientationCamera: false });
    console.log("Using VR helper");
  }

};

var createScene = async function () {

  // Create the scene space
  var scene = new BABYLON.Scene(engine);
  scene.gravity = new BABYLON.Vector3(0, -9.81, 0);

  // Add a camera to the scene and attach it to the canvas
   camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, 2, 0), scene);
  //camera = new BABYLON.ArcRotateCamera("Camera", 0, 2, -3, new BABYLON.Vector3(0, 1, 0), scene);
  //camera.setPosition(new BABYLON.Vector3(0, 2, -3));
  //var camera = new BABYLON.FlyCamera("FlyCamera", new BABYLON.Vector3(0, 5, -10), scene);
  camera.maxZ = 100000;
  camera.minZ = 0;
  camera.setTarget(new BABYLON.Vector3(0,1.5,3));
  camera.attachControl(canvas, true);
  camera.applyGravity = true;
  //Set the ellipsoid around the camera (e.g. your player's size)
  //camera.ellipsoid = new BABYLON.Vector3(.5, 1.8, .5);
  //camera.ellipsoidOffset = -0.2
  scene.collisionsEnabled = true;
  camera.checkCollisions = true;

  // Add lights to the scene
  var light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 0), scene);
  var light2 = new BABYLON.PointLight("light2", new BABYLON.Vector3(0, 10, 0), scene);

  // Shadows
  shadowGenerator = new BABYLON.ShadowGenerator(1024, light2);
  shadowGenerator.useBlurExponentialShadowMap = true;
  shadowGenerator.blurKernel = 32;

  var skybox = BABYLON.Mesh.CreateBox("skyBox", 100.0, scene);
  skybox.rotation = new BABYLON.Vector3( 0, Math.PI, 0 );
  var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
  skyboxMaterial.backFaceCulling = false;
  skyboxMaterial.disableLighting = true;
  skybox.material = skyboxMaterial;
  skybox.infiniteDistance = true;
  skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("../content/skybox/mp_drakeq/drakeq", scene);
  //skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("skybox/horizon_4", scene);
  skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;

  //Ground
  ground = BABYLON.Mesh.CreatePlane("ground", 40, scene);
  ground.material = new BABYLON.StandardMaterial("groundMat", scene);
  var groundTexture = new BABYLON.CloudProceduralTexture("cloud", 1024, scene);
  ground.material.ambientTexture = groundTexture;

  //ground.material.diffuseColor = new BABYLON.Color3(.5, 1, .5);
  //ground.material.backFaceCulling = false;
  ground.material.alpha = 0.5;
  ground.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0);
  ground.checkCollisions = true;
  ground.receiveShadows = true;

  // Register a render loop to repeatedly render the scene
  engine.runRenderLoop(function () {
    if (scene) scene.render();
  });

  await VRSPACEUI.init();
  return scene;
}

// Watch for browser/canvas resize events
window.addEventListener("resize", function () {
  engine.resize();
});

var selectButtons = [];

function randomColor() {
  return new BABYLON.Color4(Math.random(), Math.random, Math.random(), Math.random()/5+0.8);
}

function startParticles( dir, pos ) {
  var particleSystem;

  if (false && BABYLON.GPUParticleSystem.IsSupported) {
    // does not work in XR, renders only in one eye
    particleSystem = new BABYLON.GPUParticleSystem("particles:"+dir, { capacity:100 }, scene);
    particleSystem.activeParticleCount = 100;
  } else {
    particleSystem = new BABYLON.ParticleSystem("particles:"+dir, 100, scene);
  }

  particleSystem.worldOffset = pos;
  particleSystem.color1 = randomColor();
  particleSystem.color2 = randomColor();
  particleSystem.colorDead = new BABYLON.Color4(particleSystem.color2.r/10,particleSystem.color2.g/10,particleSystem.color2.b/10,0);
  particleSystem.emitRate = 10;
  particleSystem.particleEmitterType = new BABYLON.SphereParticleEmitter(0.5);
  particleSystem.particleTexture = new BABYLON.Texture("//www.babylonjs-playground.com//textures/flare.png", scene); // FIXME: cdn
  particleSystem.gravity = new BABYLON.Vector3(0, 2, 0);
  particleSystem.minLifeTime = 0.5;
  particleSystem.maxLifeTime = 3;
  particleSystem.minSize = 0.1;
  particleSystem.maxSize = 0.2;
  particleSystem.minEmitPower = 0.1;
  particleSystem.maxEmitPower = 0.3;
  var fountain = BABYLON.Mesh.CreateBox("foutain", 0.1, scene);
  fountain.visibility = 0;
  particleSystem.emitter = fountain;

  particleSystem.start();
  return particleSystem;
}

function createAvatarUI(avatar, manager) {

  var pos = avatar.rootMesh.position;
  var rot = avatar.rootMesh.rotationQuaternion.multiply(new BABYLON.Quaternion.RotationAxis(BABYLON.Axis.Y,Math.PI));

  var text = new BABYLON.GUI.TextBlock();
  text.text = "Avatar: "+avatar.folder.name;
  if ( avatar.info ) {
    text.text +=
    '\n\nTitle: '+avatar.info.title+
    '\n\nAuthor: '+avatar.info.author.replace('(','\n(')+
    '\n\nLicense: '+avatar.info.license.replace('(','\n(')
    //+'\nSource:\n'+avatar.info.source; // too long
    ;
  }
  text.color = "white";
  text.fontSize = 24;
  //text.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
  text.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;

  var selectButton = new BABYLON.GUI.HolographicButton("select:"+avatar.folder.name);
  selectButton.imageUrl = "//www.babylonjs-playground.com/textures/icons/Zoom.png"; // FIXME: cdn
  //selectButton.contentResolution = 1024;
  selectButton.contentScaleRatio = 4;
  selectButton.onPointerDownObservable.add( function() {
      console.log( "Selected "+avatar.folder.name );
      selectButton.imageUrl = "//www.babylonjs-playground.com/textures/icons/Back.png"; // FIXME: cdn
      if ( avatar.caption ) {
        avatar.caption.dispose();
        avatar.caption = null;
      }
      avatar.castShadows(shadowGenerator);
      for ( var i = 0; i < selectButtons.length; i++ ) {
        if ( selectButtons[i] != selectButton ) {
          selectButtons[i].isVisible = false;
        }
      }
  });
  selectButton.onPointerEnterObservable.add( function () {
      if ( ! avatar.caption ) {
        var group = new BABYLON.TransformNode();
        group.position = new BABYLON.Vector3( pos.x*0.9,1,pos.z*0.9 );
        //group.rotationQuaternion = new BABYLON.Quaternion.RotationAxis(BABYLON.Axis.Y,angle);
        group.rotationQuaternion = rot;

        var titlePlane = BABYLON.MeshBuilder.CreatePlane("Text"+avatar.folder.name, {height:1.5,width:6}, scene);
        titlePlane.parent = group;

        var titleTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(
          titlePlane,
          1024,
          256,
          false // mouse events disabled
        );
        titleTexture.addControl(text);
        avatar.caption = group;
      }
  });
  selectButton.onPointerOutObservable.add( function () {
      if ( avatar.caption ) {
        avatar.caption.dispose();
        avatar.caption = null;
      }
  });

  manager.addControl(selectButton);
  // all of these must be set after control is added to manager
  // transform node does not exist earlier
  selectButton.position = new BABYLON.Vector3( pos.x*0.9,0,pos.z*0.9 );
  //selectButton.scaling = new BABYLON.Vector3( 1.5,1.5,1.5 );
  selectButton.scaling = new BABYLON.Vector3( .2, .2, .2 );
  //selectButton.node.rotationQuaternion =  new BABYLON.Quaternion.RotationAxis(BABYLON.Axis.Y,angle);
  selectButton.node.rotationQuaternion = rot;

  selectButtons.push(selectButton);
}

function loadAvatar( dir, pos, angle, indicator, callback ) {
  var avatar = new Avatar(scene, dir);
  indicator.add(avatar);
  avatar.particles = startParticles(avatar.folder.name, pos);

  // TODO introduce avatar correction
  if ( avatar.folder.name == "charodeika_all_animation/" ) {
    avatar.fixes = { standing: 0.5};
    console.log( "fixes: "+avatar.fixes+" standing "+avatar.fixes.standing);
  } else if ( avatar.folder.name == "vanille_flirty_animation/" ) {
    avatar.fixes = { standing: 1.1 };
  } else if ( avatar.folder.name == "cyclops/" ) {
    avatar.fixes = { standing: 1 };
  } else if ( avatar.folder.name == "dancer_girl/" ) {
    avatar.fixes = { standing: 1.2 };
    //var modelCorrection = avatar.rootMesh.getChildren()[0].getChildren()[0];
    //modelCorrection.position = new BABYLON.Vector3(0,100,0);
    //modelCorrection.rotationQuaternion = new BABYLON.Quaternion();
  } else if ( avatar.folder.name == "gwen_stacy_downloadable/" ) {
    avatar.fixes = { standing: 0.15 };
  } else if ( avatar.folder.name == "capitan_america_walking/") {
    avatar.fixes = { standing: -0.12 };
  }

  avatar.load( (avatar) => {
      character = avatar;
      if ( avatar.particles ) {
        avatar.particles.emitter.dispose();
        avatar.particles.dispose();
        delete( avatar.particles );
      }
      indicator.remove(avatar);

      avatar.setPosition(pos);
      avatar.setRotation( new BABYLON.Quaternion.RotationAxis(BABYLON.Axis.Y,Math.PI+angle));

      if ( callback ) {
        callback( avatar );
      }

  },
  (evt) => { indicator.progress( evt, avatar ) }
  );
}

createScene().then( (s) => {
  scene = s;
  var indicator = new LoadProgressIndicator(scene, camera);
  initXR(scene);
  var manager = new BABYLON.GUI.GUI3DManager(scene);
  VRSPACEUI.listCharacters( '../content/char', function(avatars) {
      console.log("Avatars available: "+avatars.length);
      var circumference = 2*avatars.length; // 2m for each avatar
      var radius = circumference/Math.PI/2;
      var angleIncrement = 2*Math.PI/avatars.length;
      var angle = 0;
      for ( var i=0; i < avatars.length; i++ ) {
        var x = Math.sin(angle)*radius;
        var z = Math.cos(angle)*radius;
        var pos = new BABYLON.Vector3(x,0,z);
        loadAvatar( avatars[i], pos, angle, indicator, (avatar) => createAvatarUI(avatar,manager) );
        angle += angleIncrement;
      }
  });
});

function debugOnOff() {
  console.log("Debug: "+scene.debugLayer.isVisible());
  if ( scene.debugLayer.isVisible() ) {
    scene.debugLayer.hide();
  } else {
    scene.debugLayer.show();
  }
}

</script>
<div style="position:absolute;bottom:10px;right:50%;">
<button onClick="debugOnOff()">Debug</button>
</div>
</body>
</html>