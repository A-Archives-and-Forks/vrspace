<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
  <meta content="utf-8" http-equiv="encoding">
  <title>VRSpace</title>
  ﻿<style type="text/css">
    html, body {
      width: 100%;
      height:100%;
      margin: 0px;
      padding: 0px;
      background-color: black;
    }
    canvas {
      width: 98%;
      height:96%;
      padding-left: 0;
      padding-right: 0;
      margin-left: auto;
      margin-right: auto;
      display: block;
    }
  </style>﻿
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
  </head>

<body>

  <canvas id="renderCanvas" touch-action="none"></canvas>

<script>
var canvas = document.getElementById("renderCanvas"); // Get the canvas element
//canvas.style.width = '90%';
//canvas.style.height = '60%';
var engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
var scene;
var camera;
var FPS = 5;

/******* Add the create scene function ******/
var createScene = function () {

  // Create the scene space
  var scene = new BABYLON.Scene(engine);
  scene.gravity = new BABYLON.Vector3(0, -9.81, 0);

  // Add a camera to the scene and attach it to the canvas
  camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, 2, -10), scene);
  //var camera = new BABYLON.ArcRotateCamera("Camera", 0, 2, -3, new BABYLON.Vector3(0, 1, 0), scene);
  //camera.setPosition(new BABYLON.Vector3(0, 2, -3));
  //var camera = new BABYLON.FlyCamera("FlyCamera", new BABYLON.Vector3(0, 5, -10), scene);
  camera.maxZ = 100000;
  camera.setTarget(BABYLON.Vector3.Zero());
  camera.attachControl(canvas, true);
  //camera.applyGravity = true;
  //Set the ellipsoid around the camera (e.g. your player's size)
  //camera.ellipsoid = new BABYLON.Vector3(.5, 1.8, .5);
  //camera.ellipsoidOffset = -0.2
  scene.collisionsEnabled = true;
  camera.checkCollisions = true;

  // Add lights to the scene
  var light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 0), scene);
  var light2 = new BABYLON.PointLight("light2", new BABYLON.Vector3(1, 3, -3), scene);

  var skybox = BABYLON.Mesh.CreateBox("skyBox", 100.0, scene);
  var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
  skyboxMaterial.backFaceCulling = false;
  skyboxMaterial.disableLighting = true;
  skybox.material = skyboxMaterial;
  skybox.infiniteDistance = true;
  skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("//www.babylonjs.com/assets/skybox/TropicalSunnyDay", scene);
  skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;

  return scene;
};

// Register a render loop to repeatedly render the scene
engine.runRenderLoop(function () {
    scene.render();
});

// Watch for browser/canvas resize events
window.addEventListener("resize", function () {
    engine.resize();
});

function debugOnOff() {
  console.log("Debug: "+scene.debugLayer.isVisible());
  if ( scene.debugLayer.isVisible() ) {
    scene.debugLayer.hide();
  } else {
    scene.debugLayer.show();
  }
}

class Something {
  constructor(vrSpace) {
    this.vrSpace = vrSpace;
    this.oldx = null;
    this.oldy = null;
    this.oldz = null;
    this.oldrx = null;
    this.oldry = null;
    this.oldrz = null;
  }
  
  setConnected(connected) {
    console.log("Connected: "+connected);
  }

  sceneChanged(e) {
    if (e.added != null) {
      console.log("ADDED " + e.objectId + " new size " + e.scene.size);
      this.loadMesh(e.added);
    } else if (e.removed != null) {
      console.log("REMOVED " + e.objectId + " new size " + e.scene.size)
      this.removeMesh( e.removed );
    } else {
      console.log("ERROR: invalid scene event");
    }
  }

  // TODO loader UI
  loadMesh(obj) {
    console.log("loading "+obj.mesh);
    BABYLON.SceneLoader.LoadAssetContainerAsync("", obj.mesh, scene).then((container) => {
      console.log("loaded "+obj.mesh);

      var bbox = this.boundingBox(container);

      // Adds all elements to the scene
      var mesh = container.createRootMesh();
      mesh.name = obj.mesh;
      mesh.id = obj.constructor.name+" "+obj.id;
      
      container.addAllToScene();

      obj.container = container;
      
      console.log("Added "+obj.mesh);
      
      // TODO: add listener to process changes
      obj.addListener((obj, changes) => this.changeObject(obj, changes));
    });
  }

  changeObject(obj,changes) {
    console.log("Changes on "+obj+": "+changes);
    for ( var field in changes ) {
      var node = obj.container.meshes[0];
      if ( 'position' === field ) {
        if ( ! obj.translate ) {
          obj.translate = this.createAnimation(node, "position");
        }
        this.updateAnimation(obj.translate, node.position, obj.position);
      } else if ( 'rotation' === field ) {
        if ( ! obj.rotate ) {
          obj.rotate = this.createAnimation(node, "rotation");
        }
        this.updateAnimation(obj.rotate, node.rotation, obj.rotation);
      }
    }
  }

  updateAnimation(group, from, to) {
    if ( group.isPlaying ) {
      group.stop();
    }
    var xAnim = group.targetedAnimations[0].animation;
    xAnim.getKeys()[0].value = from.x;
    xAnim.getKeys()[1].value = to.x;
    var yAnim = group.targetedAnimations[1].animation;
    yAnim.getKeys()[0].value = from.y;
    yAnim.getKeys()[1].value = to.y;
    var zAnim = group.targetedAnimations[2].animation;
    zAnim.getKeys()[0].value = from.z;
    zAnim.getKeys()[1].value = to.z;
    group.play(false);
  }
  
  createAnimation(mesh, field) {
    var group = new BABYLON.AnimationGroup(field+" "+mesh.id);
    
    var xAnim = new BABYLON.Animation("xAnim "+mesh.id, field+".x", FPS, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
    var xKeys = []; 
    xKeys.push({frame:0, value: 0});
    xKeys.push({frame:1, value: 0});
    xAnim.setKeys(xKeys);
    
    var yAnim = new BABYLON.Animation("yAnim "+mesh.id, field+".y", FPS, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
    var xKeys = []; 
    xKeys.push({frame:0, value: 0});
    xKeys.push({frame:1, value: 0});
    yAnim.setKeys(xKeys);

    var zAnim = new BABYLON.Animation("zAnim "+mesh.id, field+".z", FPS, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
    var xKeys = []; 
    xKeys.push({frame:0, value: 0});
    xKeys.push({frame:1, value: 0});
    zAnim.setKeys(xKeys);

    group.addTargetedAnimation(xAnim, mesh);
    group.addTargetedAnimation(yAnim, mesh);
    group.addTargetedAnimation(zAnim, mesh);

    return group;
  }
  
  removeMesh(obj) {
    if ( obj.container ) {
      obj.container.dispose();
      obj.container = null;
    }
    if ( obj.translate ) {
      obj.translate.dispose();
      obj.translate = null;
    }
    if ( obj.rotate ) {
      obj.rotate.dispose();
      obj.rotate = null;
    }
  }

  boundingBox(container) {
    var maxSize = new BABYLON.Vector3(0,0,0);
    for ( var i = 0; i < container.meshes.length; i++ ) {
      // have to recompute after scaling
      //container.meshes[i].computeWorldMatrix(true);
      container.meshes[i].refreshBoundingInfo();
      var boundingInfo = container.meshes[i].getBoundingInfo().boundingBox;
      console.log("max: "+boundingInfo.maximumWorld+" min: "+boundingInfo.minimumWorld);
      var size = new BABYLON.Vector3(
        boundingInfo.maximumWorld.x - boundingInfo.minimumWorld.x,
        boundingInfo.maximumWorld.y - boundingInfo.minimumWorld.y,
        boundingInfo.maximumWorld.z - boundingInfo.minimumWorld.z
        );
      maxSize.x = Math.max(maxSize.x,size.x);
      maxSize.y = Math.max(maxSize.y,size.y);
      maxSize.z = Math.max(maxSize.z,size.z);
      //if (shadows) {
        //shadowGenerator.getShadowMap().renderList.push(container.meshes[i]);
      //}
    }
    console.log("BBoxMax: "+maxSize);
    return maxSize;
  }

  position() {
    if ( typeof oldPos != 'object') {
      this.oldPos = camera.globalPosition;
    }
    if ( typeof oldRot != 'object') {
      this.oldRot = camera.rotation;
    }
    if ( this.oldx != camera.globalPosition.x || this.oldy != camera.globalPosition.y || this.oldz != camera.globalPosition.z ) {
      this.oldx = camera.globalPosition.x;
      this.oldy = camera.globalPosition.y;
      this.oldz = camera.globalPosition.z;
      this.vrSpace.sendMy("position", camera.globalPosition);
    }
    if ( this.oldrx != camera.rotation.x || this.oldry != camera.rotation.y || this.oldrz != camera.rotation.z ) {
      this.oldrx = camera.rotation.x;
      this.oldry = camera.rotation.y;
      this.oldrz = camera.rotation.z;
      this.vrSpace.sendMy("rotation", camera.rotation);
    }
  }

}


scene = createScene();

import('./vrspace.js').then((vrspace) => {
  var something = new Something(vrspace.VRSPACE);
  
  vrspace.VRSPACE.addConnectionListener((connected) => something.setConnected(connected));
  vrspace.VRSPACE.addSceneListener((e) => something.sceneChanged(e));

  vrspace.VRSPACE.connect();

  setInterval(() => something.position(), 1000/FPS);
});

</script>
<div style="position:absolute;bottom:10px;right:50%;">
<button onClick="debugOnOff()">Debug</button>
</div>
</body>
</html>
