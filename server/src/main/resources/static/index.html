<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
  <meta content="utf-8" http-equiv="encoding">
  <title>VRSpace</title>
  ﻿<style type="text/css">
    html, body {
      width: 100%;
      height:100%;
      margin: 0px;
      padding: 0px;
      background-color: black;
    }
    canvas {
      width: 98%;
      height:96%;
      padding-left: 0;
      padding-right: 0;
      margin-left: auto;
      margin-right: auto;
      display: block;
    }
  </style>﻿
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    <script src="vrspace.js"></script>
  </head>

<body>

  <canvas id="renderCanvas" touch-action="none"></canvas>

<script>
var canvas = document.getElementById("renderCanvas"); // Get the canvas element
//canvas.style.width = '90%';
//canvas.style.height = '60%';
var engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
var scene;
var camera;
var FPS = 5;

/******* Add the create scene function ******/
var createScene = function () {

  // Create the scene space
  var scene = new BABYLON.Scene(engine);
  scene.gravity = new BABYLON.Vector3(0, -9.81, 0);

  // Add a camera to the scene and attach it to the canvas
  camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, 2, -10), scene);
  //var camera = new BABYLON.ArcRotateCamera("Camera", 0, 2, -3, new BABYLON.Vector3(0, 1, 0), scene);
  //camera.setPosition(new BABYLON.Vector3(0, 2, -3));
  //var camera = new BABYLON.FlyCamera("FlyCamera", new BABYLON.Vector3(0, 5, -10), scene);
  camera.maxZ = 100000;
  camera.setTarget(BABYLON.Vector3.Zero());
  camera.attachControl(canvas, true);
  //camera.applyGravity = true;
  //Set the ellipsoid around the camera (e.g. your player's size)
  //camera.ellipsoid = new BABYLON.Vector3(.5, 1.8, .5);
  //camera.ellipsoidOffset = -0.2
  scene.collisionsEnabled = true;
  camera.checkCollisions = true;

  // Add lights to the scene
  var light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 0), scene);
  var light2 = new BABYLON.PointLight("light2", new BABYLON.Vector3(1, 3, -3), scene);

  var skybox = BABYLON.Mesh.CreateBox("skyBox", 100.0, scene);
  var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
  skyboxMaterial.backFaceCulling = false;
  skyboxMaterial.disableLighting = true;
  skybox.material = skyboxMaterial;
  skybox.infiniteDistance = true;
  skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("skybox/mp_orbital/orbital-element", scene);
  //skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("skybox/mp_drakeq/drakeq", scene);
  skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;

  return scene;
};

// Register a render loop to repeatedly render the scene
engine.runRenderLoop(function () {
    scene.render();
});

// Watch for browser/canvas resize events
window.addEventListener("resize", function () {
    engine.resize();
});

function debugOnOff() {
  console.log("Debug: "+scene.debugLayer.isVisible());
  if ( scene.debugLayer.isVisible() ) {
    scene.debugLayer.hide();
  } else {
    scene.debugLayer.show();
  }
}

function setConnected(connected) {
  console.log("Connected: "+connected);
}

function sceneChanged(e) {
  if (e.added != null) {
    console.log("ADDED " + e.objectId + " new size " + e.scene.size);
    loadMesh(e.added);
  } else if (e.removed != null) {
    console.log("REMOVED " + e.objectId + " new size " + e.scene.size)
    removeMesh( e.removed );
  } else {
    console.log("ERROR: invalid scene event");
  }
}

function loadMesh(obj) {
  console.log("loading "+obj.mesh);
  BABYLON.SceneLoader.LoadAssetContainerAsync("", obj.mesh, scene).then(function (container) {
    console.log("loaded "+obj.mesh);

    var bbox = boundingBox(container);

    // Adds all elements to the scene
    var mesh = container.createRootMesh();
    mesh.name = obj.mesh;
    mesh.id = obj.constructor.name+" "+obj.id;
    
    container.addAllToScene();

    obj.container = container;
    
    console.log("Added "+obj.mesh);
    
    // TODO: add listener to process changes
    obj.addListener(changeObject);
  });
}

function changeObject(obj,changes) {
  for ( field in changes ) {
    var node = obj.container.meshes[0];
    if ( 'position' === field ) {
      if ( ! obj.translate ) {
        obj.translate = createAnimation(node, "position");
      }
      updateAnimation(obj.translate, node.position, obj.position);
    } else if ( 'rotation' === field ) {
      if ( ! obj.rotate ) {
        obj.rotate = createAnimation(node, "rotation");
      }
      updateAnimation(obj.rotate, node.rotation, obj.rotation);
    }
  }
}

function updateAnimation(group, from, to) {
  if ( group.isPlaying ) {
    group.stop();
  }
  var xAnim = group.targetedAnimations[0].animation;
  xAnim.getKeys()[0].value = from.x;
  xAnim.getKeys()[1].value = to.x;
  var yAnim = group.targetedAnimations[1].animation;
  yAnim.getKeys()[0].value = from.y;
  yAnim.getKeys()[1].value = to.y;
  var zAnim = group.targetedAnimations[2].animation;
  zAnim.getKeys()[0].value = from.z;
  zAnim.getKeys()[1].value = to.z;
  group.play(false);
}

function createAnimation(mesh, field) {
  var group = new BABYLON.AnimationGroup(field+" "+mesh.id);
  
  var xAnim = new BABYLON.Animation("xAnim "+mesh.id, field+".x", FPS, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
  var xKeys = []; 
  xKeys.push({frame:0, value: 0});
  xKeys.push({frame:1, value: 0});
  xAnim.setKeys(xKeys);
  
  var yAnim = new BABYLON.Animation("yAnim "+mesh.id, field+".y", FPS, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
  var xKeys = []; 
  xKeys.push({frame:0, value: 0});
  xKeys.push({frame:1, value: 0});
  yAnim.setKeys(xKeys);

  var zAnim = new BABYLON.Animation("zAnim "+mesh.id, field+".z", FPS, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
  var xKeys = []; 
  xKeys.push({frame:0, value: 0});
  xKeys.push({frame:1, value: 0});
  zAnim.setKeys(xKeys);

  group.addTargetedAnimation(xAnim, mesh);
  group.addTargetedAnimation(yAnim, mesh);
  group.addTargetedAnimation(zAnim, mesh);

  return group;
}

function removeMesh(obj) {
  if ( obj.container ) {
    obj.container.dispose();
    obj.container = null;
  }
  if ( obj.translate ) {
    obj.translate.dispose();
    obj.translate = null;
  }
  if ( obj.rotate ) {
    obj.rotate.dispose();
    obj.rotate = null;
  }
}

function boundingBox(container) {
  var maxSize = new BABYLON.Vector3(0,0,0);
  for ( i = 0; i < container.meshes.length; i++ ) {
    // have to recompute after scaling
    //container.meshes[i].computeWorldMatrix(true);
    container.meshes[i].refreshBoundingInfo();
    boundingInfo = container.meshes[i].getBoundingInfo().boundingBox;
    console.log("max: "+boundingInfo.maximumWorld+" min: "+boundingInfo.minimumWorld);
    var size = new BABYLON.Vector3(
      boundingInfo.maximumWorld.x - boundingInfo.minimumWorld.x,
      boundingInfo.maximumWorld.y - boundingInfo.minimumWorld.y,
      boundingInfo.maximumWorld.z - boundingInfo.minimumWorld.z
      );
    maxSize.x = Math.max(maxSize.x,size.x);
    maxSize.y = Math.max(maxSize.y,size.y);
    maxSize.z = Math.max(maxSize.z,size.z);
    //if (shadows) {
      //shadowGenerator.getShadowMap().renderList.push(container.meshes[i]);
    //}
  }
  console.log("BBoxMax: "+maxSize);
  return maxSize;
}

var oldx, oldy, oldz;
var oldrx, oldry, oldrz;

function position() {
  if ( typeof oldPos != 'object') {
    oldPos = camera.globalPosition;
  }
  if ( typeof oldRot != 'object') {
    oldRot = camera.rotation;
  }
  if ( oldx != camera.globalPosition.x || oldy != camera.globalPosition.y || oldz != camera.globalPosition.z ) {
    console.log(camera.cameraDirection);
    oldx = camera.globalPosition.x;
    oldy = camera.globalPosition.y;
    oldz = camera.globalPosition.z;
    VRSPACE.sendMy("position", camera.globalPosition);
  }
  if ( oldrx != camera.rotation.x || oldry != camera.rotation.y || oldrz != camera.rotation.z ) {
    oldrx = camera.rotation.x;
    oldry = camera.rotation.y;
    oldrz = camera.rotation.z;
    VRSPACE.sendMy("rotation", camera.rotation);
  }
}

scene = createScene();

VRSPACE.addConnectionListener(setConnected);
VRSPACE.addSceneListener(sceneChanged);

VRSPACE.connect();

setInterval(position, 1000/FPS);

</script>
<div style="position:absolute;bottom:10px;right:50%;">
<button onClick="debugOnOff()">Debug</button>
</div>
</body>
</html>
